import { Controller, Get, Post, Param, UseGuards, ForbiddenException, Body, Put } from '@nestjs/common';
import { ApiTags, ApiOperation, ApiResponse, ApiBearerAuth } from '@nestjs/swagger';
import { JwtAuthGuard } from '../modules/auth/guards/jwt-auth.guard';
import { ResourceConflictService } from './resource-conflict.service';
import { ConflictException } from '@nestjs/common';

@Controller('resources')
@ApiTags('resources')
@UseGuards(JwtAuthGuard)
@ApiBearerAuth()
export class ResourcesController {
  constructor(private readonly resourceConflictService: ResourceConflictService) {}

  @Get('conflicts')
  @ApiOperation({ summary: 'Get all active resource conflicts' })
  @ApiResponse({ 
    status: 200, 
    description: 'List of active resource conflicts',
    schema: {
      type: 'array',
      items: {
        type: 'object',
        properties: {
          id: { type: 'string' },
          resourceId: { type: 'string' },
          conflictDate: { type: 'string', format: 'date' },
          totalAllocation: { type: 'number' },
          severity: { type: 'string', enum: ['low', 'medium', 'high', 'critical'] },
          affectedProjects: { type: 'array' },
          resolved: { type: 'boolean' },
          detectedAt: { type: 'string', format: 'date-time' }
        }
      }
    }
  })
  async getActiveConflicts() {
    return this.resourceConflictService.getActiveConflicts();
  }

  @Get('conflicts/:resourceId')
  @ApiOperation({ summary: 'Get conflicts for a specific resource' })
  @ApiResponse({ 
    status: 200, 
    description: 'List of conflicts for the specified resource',
    schema: {
      type: 'array',
      items: {
        type: 'object',
        properties: {
          id: { type: 'string' },
          resourceId: { type: 'string' },
          conflictDate: { type: 'string', format: 'date' },
          totalAllocation: { type: 'number' },
          severity: { type: 'string', enum: ['low', 'medium', 'high', 'critical'] },
          affectedProjects: { type: 'array' },
          resolved: { type: 'boolean' },
          detectedAt: { type: 'string', format: 'date-time' }
        }
      }
    }
  })
  async getConflictsByResource(@Param('resourceId') resourceId: string) {
    return this.resourceConflictService.getConflictsByResource(resourceId);
  }

  @Get('test')
  @ApiOperation({ summary: 'Test endpoint for resources module' })
  @ApiResponse({ status: 200, description: 'Resources module is working' })
  async test() {
    return { message: 'Resources module is working!', timestamp: new Date() };
  }

  @Post('detect-conflicts')
  @ApiOperation({ summary: 'Manually trigger conflict detection' })
  @ApiResponse({ status: 200, description: 'Conflict detection completed' })
  async detectConflictsNow() {
    await this.resourceConflictService.detectConflicts();
    return { message: 'Conflict detection completed' };
  }

  @Post('allocations')
  @ApiOperation({ summary: 'Create a new resource allocation with conflict prevention' })
  @ApiResponse({ status: 201, description: 'Allocation created successfully' })
  @ApiResponse({ status: 409, description: 'Allocation would create conflicts' })
  async createAllocation(@Body() allocationData: any) {
    try {
      const allocation = await this.resourceConflictService.createAllocation(allocationData);
      return { message: 'Allocation created successfully', allocation };
    } catch (error) {
      if (error instanceof ConflictException) {
        throw error;
      }
      throw new Error('Failed to create allocation');
    }
  }

  @Put('allocations/:id')
  @ApiOperation({ summary: 'Update a resource allocation with conflict prevention' })
  @ApiResponse({ status: 200, description: 'Allocation updated successfully' })
  @ApiResponse({ status: 409, description: 'Update would create conflicts' })
  async updateAllocation(@Param('id') id: string, @Body() allocationData: any) {
    try {
      const allocation = await this.resourceConflictService.updateAllocation(id, allocationData);
      return { message: 'Allocation updated successfully', allocation };
    } catch (error) {
      if (error instanceof ConflictException) {
        throw error;
      }
      throw new Error('Failed to update allocation');
    }
  }

  @Post('seed-test-data')
  @UseGuards() // Override global guard
  @ApiOperation({ summary: 'Create test data for development' })
  @ApiResponse({ status: 200, description: 'Test data created successfully' })
  @ApiResponse({ status: 403, description: 'Not allowed in production' })
  async seedTestData() {
    if (process.env.NODE_ENV === 'production') {
      throw new ForbiddenException('Cannot seed in production');
    }
    
    // Create test data using properly injected services
    return await this.resourceConflictService.createTestData();
  }

  @Get('seed-test-data-public')
  @ApiOperation({ summary: 'Create test data for development (public)' })
  @ApiResponse({ status: 200, description: 'Test data created successfully' })
  @ApiResponse({ status: 403, description: 'Not allowed in production' })
  async seedTestDataPublic() {
    if (process.env.NODE_ENV === 'production') {
      throw new ForbiddenException('Cannot seed in production');
    }
    
    // Create test data using properly injected services
    return await this.resourceConflictService.createTestData();
  }

  @Get('test-simple')
  @ApiOperation({ summary: 'Simple test endpoint' })
  @ApiResponse({ status: 200, description: 'Simple test successful' })
  async testSimple() {
    return { 
      message: 'Simple test successful!', 
      timestamp: new Date(),
      environment: process.env.NODE_ENV,
      canSeed: process.env.NODE_ENV !== 'production'
    };
  }
}
