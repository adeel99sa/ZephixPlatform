---
alwaysApply: true
---

# These Rules Are for the ENTIRE Zephix App


## **Complete Zephix Platform Development Rules**

```yaml
# .cursorrules - ZEPHIX PLATFORM STANDARDS

## PLATFORM SCOPE
These rules apply to ALL Zephix development:
- Project Management (tasks, phases, resources)
- AI Assistant features
- Risk Management system
- Resource Allocation & Heat Maps
- Admin Dashboards
- Template System
- Reporting & Analytics
- Integration Layer
- Authentication & Security
- All future features

## MANDATORY RESPONSE FORMAT
[Keep the same simple template for consistency]

## CORE PLATFORM PRINCIPLES

### 1. SECURITY FIRST (All Features)
- Authentication required for all endpoints
- Organization-level data isolation
- Row-level security on all queries
- Input validation on every endpoint
- No sensitive data in frontend storage

### 2. MULTI-TENANCY (Platform-Wide)
Every database query MUST include organization filtering:
```typescript
// WRONG
const projects = await projectRepository.find();

// RIGHT
const projects = await projectRepository.find({
  where: { organizationId: user.organizationId }
});
```

### 3. AI INTEGRATION STANDARDS
When building AI features:
- Always provide evidence/reasoning
- Human in the loop (no autonomous actions)
- Token usage tracking
- Fallback for when AI unavailable
- Cache AI responses when possible

### 4. RESOURCE MANAGEMENT RULES
For any resource allocation feature:
- Check conflicts before assignment
- Respect configurable thresholds
- Show heat maps/utilization
- Calculate cascading impacts
- Provide override capability

### 5. RISK DETECTION STANDARDS
For risk-related features:
- Run automated rules on schedule
- Provide evidence for each risk
- Allow acknowledgment/dismissal
- Track mitigation actions
- Roll up to portfolio level

## PLATFORM-WIDE TECHNICAL STANDARDS

### Database Architecture
- Every table has: id, created_at, updated_at, organization_id
- Soft deletes where appropriate (deleted_at)
- Audit fields (created_by, updated_by)
- Proper indexes for common queries
- Foreign keys for data integrity

### API Standards
- Versioned endpoints (/api/v1/)
- Consistent error responses
- Pagination for lists
- Rate limiting
- Request/response logging

### Frontend Standards
- Loading states for all async operations
- Error boundaries on components
- Responsive design (mobile-first)
- Accessibility (WCAG 2.2 AA)
- Performance (lazy loading, code splitting)

### Integration Standards
- Webhook support for events
- Bulk operations where needed
- Import/export capabilities
- API documentation (OpenAPI)
- Rate limit compliance for external APIs

## FEATURE-SPECIFIC RULES

### Project Management Features
- Tasks must belong to phases
- Phases must belong to projects
- Dependencies create network effects
- Progress rolls up automatically

### AI Assistant Features
- Pre-built questions to save tokens
- Context from current view
- Explainable recommendations
- Audit trail of suggestions

### Resource Management Features
- Real-time availability checking
- Conflict prevention (not just detection)
- What-if scenarios
- Capacity forecasting

### Admin Dashboard Features
- Aggregated views across projects
- Drill-down capability
- Export functionality
- Real-time updates

## PLATFORM CONSISTENCY REQUIREMENTS

### Naming Conventions (Everywhere)
- Database: snake_case
- TypeScript: camelCase
- Components: PascalCase
- Files: kebab-case
- Routes: kebab-case

### State Management
- Zustand for global state
- React Query for server state
- Local state for component-only
- No prop drilling beyond 2 levels

### Error Handling Pattern
```typescript
try {
  // Operation
  return { success: true, data };
} catch (error) {
  logger.error('Context', error);
  return { 
    success: false, 
    error: {
      code: 'ERROR_CODE',
      message: 'User-friendly message'
    }
  };
}
```

## BUILD VERIFICATION (All Components)

### Backend Services
- npm run build (must pass)
- npm run test (if tests exist)
- npm run lint (no errors)

### Frontend Application
- npm run type-check (no errors)
- npm run build (must complete)
- npm run test (if tests exist)

### Database Changes
- Migration runs successfully
- Rollback works
- Indexes created
- Constraints enforced

## PLATFORM INTEGRATION POINTS

When building ANY feature, consider:
1. How does it affect resource allocation?
2. What risks does it create/mitigate?
3. What AI assistance would help?
4. What admin visibility is needed?
5. What reports should include this?

## SUCCESS CRITERIA FOR ANY FEATURE

✅ Follows multi-tenancy rules
✅ Has proper error handling
✅ Includes loading/error states
✅ Respects organization boundaries
✅ Integrates with existing systems
✅ Has verification tests
✅ Maintains platform consistency
```

## **Why Platform-Wide Rules Matter**

1. **Consistency** - Users expect the same patterns everywhere
2. **Maintainability** - Developers know what to expect
3. **Security** - One weak feature compromises everything
4. **Integration** - Features must work together
5. **Scalability** - Standards ensure growth capability

The rules should cover the entire platform because Zephix is an integrated system where:
- Project tasks affect resource allocation
- Resource allocation triggers risk detection
- Risks need AI assistance for mitigation
- Everything rolls up to admin dashboards

A mistake in any module affects the whole platform.